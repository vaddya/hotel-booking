\include{settings}

\begin{document}

\include{titlepage}

\tableofcontents
\newpage

\section{Цель работы}

Познакомиться с языком создания запросов управления данными SQL-DML.

\section{Программа работы}

\begin{enumerate}
	\item Изучение SQL-DML.
	\item Выполнение всех запросов из списка стандартных запросов. Демонстрация результатов преподавателю.
	\item Получение у преподавателя и реализация SQL-запросов в соответствии с индивидуальным заданием. Демонстрация результатов преподавателю.
	\item Сохранение в БД выполненных запросов \code{SELECT} в виде представлений, запросов \code{INSERT}, \code{UPDATE} или \code{DELETE} -- в виде ХП. Выкладывание скрипта в GitLab.
\end{enumerate}

\section{Стандартные запросы}

%\subsection{Выборка всех данных}

%Сделайте выборку всех данных из каждой таблицы

\subsection{Выборка с использованием логических операций}

\paragraph{Задание:} Сделайте выборку данных из одной таблицы при нескольких условиях, с использованием логических операций, \code{LIKE}, \code{BETWEEN}, \code{IN} (не менее 3-х разных примеров).

Выборка бронирований указанных после \code{IN} пользователей:
\sql{select-in}

Выборка бронирований между датами, указанными после \code{BETWEEN}:
\sql{select-between}

Выборка пользователей, имя которых начинается с <<вадим>> и номер телефона начинается с единицы:
\sql{select-like}

\subsection{Запрос с вычисляемым полем}

\paragraph{Задание:} Создайте в запросе вычисляемое поле. 

Вычисляемые значения: длительность бронирования и вычисление стоимости бронирования одного дня: 
\sql{select-eval}

\newpage

\subsection{Выборка с использованием сортировки}

\paragraph{Задание:} Сделайте выборку всех данных с сортировкой по нескольким полям.

Выборка бронирований с сортировкой по флагу оплаты заказа в порядке убывания (оплаченные заказы будут выше) и стоимости в порядке убывания. 
\sql{select-order}

\subsection{Запрос с вычислением совокупных характеристик таблиц}

\paragraph{Задание:} Создайте запрос, вычисляющий несколько совокупных характеристик таблиц.

Выборка с вычисление совокупных характеристик: количества бронирований, средней продолжительности бронирования, средней и максимальной стоимости заказа и суммы стоимости всех бронирований:
\sql{select-summary}

\newpage

\subsection{Выборка из связанных таблиц}

\paragraph{Задание:} Сделайте выборку данных из связанных таблиц (не менее двух примеров).

Соединение бронирований, комнат и тип комнат:
\sql{select-join-1}

Соединение пользователей, городов и стран:
\sql{select-join-2}

\newpage

\subsection{Запрос с использованием группировки}

\paragraph{Задание:} Создайте запрос, рассчитывающий совокупную характеристику с использованием группировки, наложите ограничение на результат группировки.

Группировка бронирований по пользователю с накладываемым условием, что число бронирований у пользователя больше 30:
\sql{select-group}

\subsection{Вложенный запрос}

\paragraph{Задание:} Придумайте пример использования вложенного запроса.

Вложенный запрос: выборка пользователей, имеющих более 30 бронирований, и соединение с таблицей пользователей после этого:
\sql{select-subquery}

\subsection{Вставка записей}

\paragraph{Задание:} С помощью оператора \code{INSERT} добавьте в каждую таблицу по одной записи.

\lstinputlisting[caption=\code{insert.sql}]{../lab2/sql/insert.sql}

\subsection{Изменение записей}

\paragraph{Задание:} С помощью оператора \code{UPDATE} измените значения нескольких полей у всех записей, отвечающих заданному условию.

Выставление цены бронирования, равной 1\$, в строках, где цена оказалась равна 0\$. Для наглядности до и после добавим запросы выборки таких строк:
\sql{update}

\subsection{Удаление записей по условию}

\paragraph{Задание:} С помощью оператора \code{DELETE} удалите запись, имеющую максимальное (минимальное) значение некоторой совокупной характеристики.

Удаление строки из таблицы цен, имеющую максимальную цену. Для наглядности до и после добавим запросы выборки таких строк:
\sql{delete-1}

\subsection{Удаление с использованием вложенного запроса}

\paragraph{Задание:} С помощью оператора \code{DELETE} удалите записи в главной таблице, на которые не ссылается подчиненная таблица (используя вложенный запрос).

Удаление пользователей, не имеющих бронирований.  Для наглядности до и после добавим запросы выборки таких строк:
\sql{delete-2}

\newpage

\section{Запросы в соответствие с задание преподавателя}

\subsection{Рейтинг городов по кварталам}

\paragraph{Задание:} Вывести рейтинг городов по кварталам. В рейтинге 5 городов в, которые больше всего ездят в каком-то квартале.

Будем формировать итоговый запрос поэтапно:
\begin{enumerate}[leftmargin=0em]
	\item Формирование отчета посещаемости городов по кварталам. Для удобства упорядочим по городу и кварталу и возьмем записи для первых двух городов:
	\sql{quarter-quarter-summary}


	\item Формирование порядкового номера полученной строки посещаемости города относительно других городов в рамках квартала. Для этого используется оконная функция \code{ROW\_NUMBER()}, условие \code{PARTITION BY} разбивает строки на наборы меньшего набора (в нашем случае разбивает по кварталам), а \code{ORDER BY} указывает на порядок внутри этого набора (в нашем случае по уменьшению бронирований). Для удобства так же возьмем записи о первых двух городах:
	\sql{quarter-summary}

	\item Формирование итогового рейтинга городов по кварталам. Для этого из предыдущего запроса берутся строки с порядковым номером 1, что соответствует ID городов, в которых забронировано больше всего номеров в одном из кварталов. После этого по ID соединяются города и страны:
\sql{quarter}
\end{enumerate}

\paragraph{Измерение времени:} увеличим количество бронирований до 100 тысяч с помощью генератора и измерим время исполнения итогового запроса:

\begin{enumerate}
	\item execution time: 309 ms, fetching time: 54 ms
	\item execution time: 196 ms, fetching time: 23 ms
	\item execution time: 183 ms, fetching time: 11 ms
\end{enumerate}

Видно, что после первого запуска время выполнения запроса сильно уменьшилось, что объясняется внутренними оптимизациями базы данных.

\subsection{Клиенты, имеющие наибольший средний рост стоимости путевки}

\paragraph{Задание:} Вывести 5 клиентов, которые имеют наибольший средний рост стоимости путевки.

Будем формировать итоговый запрос поэтапно:
\begin{enumerate}[leftmargin=0em]
	\item Формирование порядкового номера бронирования относительно бронирований отдельного пользователя. Для этого так же используется оконная функция \code{ROW\_NUMBER()} с ID пользователя как условием разбивания на наборы и датой начала бронирования для упорядочивания. Для анализа используются только пользователи, имеющие более 10 заказов. Для удобства возьмем только первые 10 строк:
	\sql{travellers-increase-summary}
	
	\item Формирование для каждого пользователя средней разницы между стоимостью соседних (относительно даты) бронирований и выбор 5 клиентов с наибольшим этим показателем: 
	\sql{travellers-summary}
	
	\item Формирование сводной таблицы 5 клиентов, имеющих наибольший средний рост стоимости путевки: ID и имя пользователя, количество бронирований, суммарная стоимость бронирований и средняя разница между бронированиями:
	\sql{travellers}
\end{enumerate}

\paragraph{Измерение времени:} увеличим количество бронирований до 100 тысяч с помощью генератора и измерим время исполнения итогового запроса:

\begin{enumerate}
	\item execution time: 85 ms, fetching time: 33 ms
	\item execution time: 75 ms, fetching time: 9 ms
	\item execution time: 73 ms, fetching time: 9 ms
\end{enumerate}

Видно, что после первого запуска время исполнения несильно уменьшилось. 

\section{Представления и хранимые процедуры}

Оформим стандартные запросы и запросы, заданные преподавателем, в виде представлений. Представления -- виртуальные именованные таблицы, создаваемые с помощью запроса \code{SELECT}.

\lstinputlisting[caption=\code{views.sql}]{sql/views.sql}

Оформим запросы изменения и удаления данных как хранимые процедуры. Однако, хранимые процедуры появятся только в PostgreSQL11, поэтому оформим не как процедуры, а как функции, возвращающие void.

\lstinputlisting[caption=\code{functions.sql}]{sql/functions.sql}

\section{Выводы}

В процессе выполнения данной работы:
\begin{itemize}
	\item изучен SQL-DML;
	\item выполнены стандартные запросы выборки данных: с условиями, вычисляемыми полями, совокупными характеристиками, с соединениями, с использованием группировки и сортировки;
	\item выполнены запросы вставки тестовых данных;
	\item выполнены запросы удаления данных по различным условиям;
	\item выполнены запросы выборки данных, заданные преподавателем: формирование рейтинга городов по кварталам и выбор 5 клиентов, имеющих наибольший средний рост стоимости путевки;
	\item запросы выборки оформлены как представления, а изменения и удаления как хранимые процедуры.
\end{itemize}


\end{document}
