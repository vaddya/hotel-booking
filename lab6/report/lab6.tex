\include{settings}

\begin{document}

\include{titlepage}

\tableofcontents
\newpage

\section{Цель работы}

Познакомить студентов с возможностями реализации более сложной обработки данных на стороне сервера с помощью хранимых процедур и триггеров.

\section{Программа работы}

\begin{enumerate}
	\item Создание двух триггеров: один триггер для автоматического заполнения ключевого поля, второй триггер для контроля целостности данных в подчиненной таблице при удалении/изменении записей в главной таблице.
	\item Создание триггера в соответствии с индивидуальным заданием, полученным у преподавателя.
	\item Создание триггера в соответствии с индивидуальным заданием, вызывающего хранимую процедуру.
	\item Выкладывание скрипта с созданными сущностями в GitLab.
	\item Демонстрация результатов преподавателю.
\end{enumerate}

\section{Хранимые процедуры}

\subsection{Автоматическое заполнение ключевого поля}

Создадим триггер для автоматического заполнения ID в таблице \code{room_type}. Внутри триггера, для наглядности, будем брать следующее значение последовательности \code{room_type_id_seq} и прибавлять 100.

\lstinputlisting[caption=\code{primary_key_trigger.sql}]{sql/primary_key_trigger.sql}

Видно, что триггер сработал и заполнил значение ключевого поля.

Контроль целостности данных в подчиненных таблицах обеспечивается ограничениями \code{constraints} внешних ключей.

\lstinputlisting[caption=\code{foreign_key_trigger.sql}]{sql/foreign_key_trigger.sql}

\vspace{-1em}
\subsection{Расчет стоимости бронирования}

\paragraph{Задание:} Расчет стоимости бронирования по данным стоимости номеров в разные моменты времени

С помощью функции \code{generate_series} сгенерируем набор дат, на которые забронирован номер (исключим последний, так как будем считать что день выезда не входит в стоимость бронирования).

Список сгенерированных дат соединим (\code{JOIN}) с таблицей цен по условию: ID комнат совпадают и сгенерированная дата попадает в интервал дат нужной цены. Тогда сумма цен (\code{price}) будет является рассчитанной ценой данного бронирования.

\lstinputlisting[caption=\code{calculate_price.sql}]{sql/calculate_price.sql}

Попробуем добавить номер, не указывая цену, причем для наглядности возьмем даты бронирования на границе период действия цен.

\lstinputlisting[caption=\code{calculate_price_example.sql}]{sql/calculate_price_example.sql}

Видно, что цена 10-дневного бронирования была рассчитана верно: 
\begin{displaymath}
7\text{ дней} \cdot \$2,666 + 3\text{ дня} \cdot \$6,319 = \$37,619,00.
\end{displaymath}

\subsection{Проверка доступности номера}

\paragraph{Задание:} При добавлении бронирования проверять доступность номера, в случае недоступности -- выбрасывать исключение.

Для проверки доступности номера на весь период бронирования выполним подзапрос для поиска конфликтующих бронирований (с тем же номером и указанным условием на даты). После этого, если список конфликтующих бронирований не пуст, то бросим исключение, содержащее поясняющее сообщение и список.

\lstinputlisting[caption=\code{reservation_validate_availability.sql}]{sql/reservation_validate_availability.sql}

Попробуем добавить бронирование, конфликтующее по датам с бронированием, созданным в предыдущем пункте. Для наглядности попробуем несколько разных комбинаций: новое начинается до предыдущего и кончается в середине предыдущего; новое начинается до предыдущего и кончается после предыдущего и т.д.

\lstinputlisting[caption=\code{reservation_validate_availability_example.sql}]{sql/reservation_validate_availability_example.sql}

Видно, что добавление конфликтующих бронирований было отклонено.

\vspace{-1em}
\section{Выводы}

В процессе выполнения данной работы:

\begin{itemize}
	\item изучены возможности языка \code{PL/pgSQL} ;
	\item создан триггер для автоматического заполнения ключевого поля;
	\item создан триггер для автоматического расчета стоимости бронирования;
	\item создан триггер для автоматической проверки доступности номера на указанные даты при добавлении нового бронирования.
\end{itemize}

\end{document}
